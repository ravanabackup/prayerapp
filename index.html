<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Prayer RSS Feed</title>

    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Prayer Feed">

    <link rel="manifest" href="/manifest.json" />

    <link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPCqxhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAflBMVEUAAAD//v/7//8AAAAAVgD/+/8AdgAVbQD///8A////AP//zACF+gD8//8AgQC0/gD///8A//8A+QD///8A////APD+//8AkAD///8AoQC0AAD///8A////AP//uwD///8A4QD///8A/QD////5AP//tAD//wC5+QD///8ArwC0/gD///8AZQA2AAAAAXRSTlMAQObYZgAAANFJREFUeNpjYCAeMBcQBwNigLMAcT8hJ7q5pEAA4wBiyE3Mzc/Px9/b38AwMCgYFhYWBQ4ICgEMDQgIEBQZGRkZGxsbHh4ZABZ0BwaFhUeHhkdHe2dgCwsLgJmZ2ZkpKa2ZkZWdnoGBgaXl5dUNvD29PZ09vb0DBARaW1tbG5ubm5vbG9o7Ojg4ODo6FhcXF5eXl5eUlZWVkxMTPwL8AgICg4JDQsPiEoB/QxMTkwC4GgQEBAaFh4RExcfHxCb3t+fnF+AQEBAUFiYlJqZmpmbg4AADe5xM6oW2SgAAAABJRU5ErkJggg==">
    <link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPCqxhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAflBMVEUAAAD//v/7//8AAAAAVgD/+/8AdgAVbQD///8A////AP//zACF+gD8//8AgQC0/gD///8A//8A+QD///8A////APD+//8AkAD///8AoQC0AAD///8A////AP//uwD///8A4QD///8A/QD////5AP//tAD//wC5+QD///8ArwC0/gD///8AZQA2AAAAAXRSTlMAQObYZgAAANFJREFUeNpjYCAeMBcQBwNigLMAcT8hJ7q5pEAA4wBiyE3Mzc/Px9/b38AwMCgYFhYWBQ4ICgEMDQgIEBQZGRkZGxsbHh4ZABZ0BwaFhUeHhkdHe2dgCwsLgJmZ2ZkpKa2ZkZWdnoGBgaXl5dUNvD29PZ09vb0DBARaW1tbG5ubm5vbG9o7Ojg4ODo6FhcXF5eXl5eUlZWVkxMTPwL8AgICg4JDQsPiEoB/QxMTkwC4GgQEBAaFh4RExcfHxCb3t+fnF+AQEBAUFiYlJqZmpmbg4AADe5xM6oW2SgAAAABJRU5ErkJggg==">

    <style>
        /* All your styles */
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #111127;
            --bg-tertiary: #1a1a2e;
            --card-bg: rgba(255, 255, 255, 0.03);
            --glass-light: rgba(255, 255, 255, 0.08);
            --glass-medium: rgba(255, 255, 255, 0.05);
            --accent-primary: #00ff88;
            --accent-secondary: #8b5cf6;
            --accent-tertiary: #06b6d4;
            --text-primary: #ffffff;
            --text-secondary: #a8b2d1;
            --text-muted: #6b7280;
            --danger: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
            --no-stats-bg: rgba(239, 68, 68, 0.1);
            --border-subtle: rgba(255, 255, 255, 0.1);
            --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
            --shadow-xl: 0 35px 70px -15px rgba(0, 0, 0, 0.9);
        }
        /* Base Styles */
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: radial-gradient(circle at 20% 20%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(6, 182, 212, 0.15) 0%, transparent 50%),
            radial-gradient(circle at 40% 40%, rgba(0, 255, 136, 0.08) 0%, transparent 50%),
            linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }
        .wrap {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
        }
        /* Header Styles */
        header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 2rem;
            position: relative;
        }
        .title {
            display: flex;
            flex-direction: column;
            position: relative;
        }
        h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 50%, var(--accent-tertiary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.025em;
            position: relative;
        }
        h1::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 50%, var(--accent-tertiary) 100%);
            filter: blur(20px);
            opacity: 0.3;
            z-index: -1;
            animation: glow 3s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from {
                opacity: 0.2;
                transform: scale(0.95);
            }
            to {
                opacity: 0.4;
                transform: scale(1.05);
            }
        }
        p.sub {
            margin: 0.5rem 0 0 0;
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
            opacity: 0.8;
        }
        /* Channel Selector */
        .channel-selector {
            position: relative;
            margin-top: 1rem;
            margin-right: auto;
            min-width: 250px;
        }
        .channel-selector select {
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            border-radius: 0.5rem;
            background-color: var(--glass-light);
            border: 1px solid var(--border-subtle);
            color: var(--text-primary);
            appearance: none;
            cursor: pointer;
            outline: none;
        }
        .channel-selector select option {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        .channel-selector select:focus {
            outline: 2px solid var(--accent-primary);
        }
        .channel-selector::after {
            content: '▼';
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
        /* Status Card */
        .status-card {
            margin-top: 2rem;
            padding: 1.5rem;
            border-radius: 1.5rem;
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--glass-medium) 100%), var(--card-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-lg);
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            overflow: hidden;
        }
        .status-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
            animation: shimmer 3s infinite;
        }
        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }
        .status-item {
            background: var(--glass-medium);
            padding: 0.75rem 1rem;
            border-radius: 2rem;
            color: var(--text-secondary);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .status-item:hover {
            background: var(--glass-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .status-ind {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            background: var(--text-muted);
            position: relative;
        }
        .status-ind.loading {
            background: var(--warning);
            animation: pulse 2s infinite;
        }
        .status-ind.loading::after {
            content: '';
            position: absolute;
            inset: -4px;
            border: 2px solid var(--warning);
            border-radius: 50%;
            animation: ripple 2s infinite;
        }
        .status-ind.connected {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }
        .status-ind.error {
            background: var(--danger);
            animation: shake 0.5s infinite;
        }
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }
        @keyframes ripple {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(1.8);
            }
        }
        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-2px);
            }
            75% {
                transform: translateX(2px);
            }
        }
        /* Filter Buttons */
        .filters {
            margin-top: 1.5rem;
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        .filter-btn {
            border-radius: 2rem;
            padding: 0.75rem 1.5rem;
            border: 1px solid var(--border-subtle);
            background: var(--card-bg);
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        .filter-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .filter-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .filter-btn.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary); /* Ensuring text is visible */
            border-color: transparent;
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
            transform: translateY(-3px);
        }
        .filter-btn.active::before {
            opacity: 0;
        }
        /* Feed Container */
        .feed-container {
            margin-top: 2rem;
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--glass-medium) 100%), var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-subtle);
            position: relative;
            overflow: hidden;
        }
        .feed-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--accent-primary), transparent, var(--accent-secondary), transparent);
            animation: rotate 20s linear infinite;
            opacity: 0.05;
        }
        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        .feed-list {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 1;
        }
        /* Feed Items */
        .feed-item {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
            padding: 1.5rem;
            border-radius: 1rem;
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--card-bg) 100%);
            border-left: 4px solid var(--accent-secondary);
            backdrop-filter: blur(15px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .feed-item::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .feed-item:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-xl), 0 0 40px rgba(0, 255, 136, 0.2);
            border-left-color: var(--accent-primary);
        }
        .feed-item:hover::before {
            opacity: 0.03;
        }
        .feed-item.no-stats-post {
            background: linear-gradient(135deg, var(--no-stats-bg), rgba(239, 68, 68, 0.05));
            border-left-color: var(--danger);
        }
        .feed-item.new {
            animation: slideInUp 0.6s ease-out;
            border-left-color: var(--accent-primary);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        .new-badge {
            position: absolute;
            top: -12px;
            right: -12px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            font-weight: 800;
            padding: 18px 12px 6px 18px;
            transform: rotate(45deg);
            font-size: 0.8rem;
            transform-origin: 100% 100%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        /* Thumbnail */
        .thumb {
            width: 280px;
            height: 158px;
            border-radius: 0.75rem;
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
            background: linear-gradient(135deg, var(--glass-medium), var(--card-bg));
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .thumb:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }
        .thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: all 0.3s ease;
        }
        .thumb:hover img {
            transform: scale(1.1);
        }
        .play {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: all 0.3s ease;
        }
        .thumb:hover .play {
            opacity: 1;
        }
        .play::after {
            content: '';
            border-style: solid;
            border-width: 20px 0 20px 30px;
            border-color: transparent transparent transparent rgba(255, 255, 255, 0.9);
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }
        .video-player-wrapper {
            width: 280px;
            height: 158px;
            position: relative;
            flex-shrink: 0;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        .video-player-wrapper iframe {
            width: 100%;
            height: 100%;
            border-radius: 0.75rem;
        }
        .close-player-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }
        .close-player-btn:hover {
            background: rgba(255, 255, 255, 0.8);
            color: #000;
        }
        /* Content */
        .content {
            flex: 1;
            min-width: 0;
            position: relative;
        }
        .title-line {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .meta {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }
        .desc {
            color: var(--text-muted);
            margin-bottom: 1.25rem;
            line-height: 1.6;
            font-size: 0.9rem;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .actions {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: inherit;
            filter: blur(10px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .btn:hover::before {
            opacity: 0.5;
        }
        .btn.watch {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
            border-radius: 2rem;
        }
        .btn.watch:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.4);
        }
        .btn.copy {
            background: transparent;
            border: 2px solid var(--border-subtle);
            color: var(--text-secondary);
            backdrop-filter: blur(10px);
            border-radius: 2rem;
        }
        .btn.copy:hover {
            background: var(--glass-medium);
            border-color: var(--accent-tertiary);
            color: var(--accent-tertiary);
            transform: translateY(-2px);
        }
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        .modal .box {
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--card-bg) 100%);
            backdrop-filter: blur(20px);
            padding: 2rem;
            border-radius: 1.5rem;
            width: 90%;
            max-width: 500px;
            color: var(--text-primary);
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--border-subtle);
            position: relative;
            animation: slideIn 0.3s ease;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .close-x {
            position: absolute;
            right: 1.5rem;
            top: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 1.5rem;
            transition: all 0.3s ease;
            border: none;
            background: none;
        }
        .close-x:hover {
            color: var(--danger);
            transform: scale(1.1);
        }
        /* Debug Box */
        #debug {
            margin-top: 1.5rem;
            padding: 1.5rem;
            border-radius: 1rem;
            background: linear-gradient(135deg, var(--glass-medium), var(--card-bg));
            backdrop-filter: blur(15px);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            color: var(--text-secondary);
            border: 1px solid var(--border-subtle);
        }
        .timers {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .timer-chip {
            background: var(--glass-medium);
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        /* Translation Progress */
        .progress-track {
            height: 0.5rem;
            background: var(--card-bg);
            border-radius: 2rem;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.3s ease;
            position: relative;
        }
        .progress-fill::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShine 2s infinite;
        }
        @keyframes progressShine {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }
        /* Loading Animation */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        /* Responsive Design */
        @media (max-width: 1024px) {
            .wrap {
                padding: 1.5rem;
            }
            h1 {
                font-size: 2rem;
            }
            .thumb {
                width: 240px;
                height: 135px;
            }
        }
        @media (max-width: 768px) {
            .header-controls {
                flex-direction: column;
                align-items: stretch;
            }
            .feed-item {
                flex-direction: column;
            }
            .thumb, .video-player-wrapper {
                width: 100%;
                height: 200px;
            }
            .status-card {
                flex-direction: column;
                align-items: stretch;
            }
            .status-item {
                justify-content: center;
            }
            h1 {
                font-size: 1.75rem;
            }
            .channel-selector {
                margin-right: 0;
            }
        }
        @media (max-width: 480px) {
            .wrap {
                padding: 1rem;
            }
            .feed-container {
                padding: 1rem;
            }
            .feed-item {
                padding: 1rem;
            }
            h1 {
                font-size: 1.5rem;
            }
        }
        .notification {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            padding: 1rem 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-lg);
            z-index: 999;
            cursor: pointer;
            animation: fadeInRight 0.5s ease-out;
            font-weight: bold;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .notification.show {
            display: block;
            opacity: 1;
        }
        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        #flashMsg {
            position: fixed;
            right: 18px;
            bottom: 18px;
            background: linear-gradient(90deg,var(--accent-secondary),var(--accent-primary));
            color: var(--bg-primary);
            padding: 10px 14px;
            border-radius: 10px;
            font-weight: 800;
            animation: slideInUp 0.3s ease-out;
            z-index: 100;
        }
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        #refreshBtn {
            cursor: pointer;
            border: none;
            background: var(--glass-medium);
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-subtle);
        }
        #refreshBtn:hover {
            background: var(--glass-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="wrap">
        <header>
            <div class="title" id="mainTitleContainer">
                <h1 id="mainTitle">Prayer Rss Feed</h1>
                <p class="sub">Realtime RSS viewer</p>
            </div>
            <div class="header-controls" style="margin-left:auto; display:flex; gap:1.5rem; align-items:center; flex-wrap:wrap;">
                <div class="channel-selector">
                    <label for="channelSelect" class="sr-only">Select Channel</label>
                    <select id="channelSelect"></select>
                </div>
                <button id="refreshBtn" class="status-item" aria-label="Manually refresh feed" title="Manually refresh feed (Shift+R)">🔄 Refresh</button>
            </div>
        </header>

        <div class="notification" id="newPostNotification"></div>

        <div class="status-card" role="status" aria-live="polite">
            <div class="status-item"><span id="statusIndicator" class="status-ind loading"></span> Status: <strong id="statusText" style="margin-left:6px">Loading...</strong></div>
            <div class="status-item">Last update: <strong id="lastUpdate" style="margin-left:6px">Never</strong></div>
            <div class="status-item">Total posts: <strong id="totalPosts" style="margin-left:6px">0</strong></div>
            <div class="status-item">New: <strong id="newPosts" style="margin-left:6px">0</strong></div>
            <button id="openSettings" class="status-item" style="cursor:pointer;background:linear-gradient(90deg,var(--accent-primary),var(--accent-secondary));color:var(--bg-primary);border:none">
                ⚙️ Settings
            </button>
            <div style="margin-left:auto;display:flex;gap:10px;align-items:center">
                <div style="color:var(--text-secondary);font-weight:600">Theme</div>
                <button id="themeToggle" class="status-item" style="cursor:pointer">🌙</button>
            </div>
        </div>

        <div class="filters">
            <button class="filter-btn" data-filter="new" style="display:none">New (0)</button>
            <button class="filter-btn active" data-filter="all">All (0)</button>
            <button class="filter-btn" data-filter="released" style="display:none">Released (0)</button>
            <button class="filter-btn" data-filter="scheduled" style="display:none">Scheduled (0)</button>
            <button class="filter-btn" data-filter="live" style="display:none">Live (0)</button>
        </div>

        <div class="feed-container" id="feedContainer">
            <div id="feedList" class="feed-list">
                <div style="padding:28px;text-align:center;color:var(--text-muted)" id="loadingBox">
                    <div style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.04);border-top-color:var(--accent-primary);margin:0 auto 12px;animation:spin 1s linear infinite"></div>
                    Loading RSS feed...
                </div>
            </div>
        </div>

        <div id="debug" aria-hidden="false">
            <div class="timers">
                <div class="timer-chip">Next feed check: <span id="feedTimer">--:--</span></div>
                <div class="timer-chip">Next YouTube API: <span id="ytTimer">--:--</span></div>
                <div class="timer-chip">Fetch candidate: <span id="lastCandidate" style="margin-left:6px">-</span></div>
            </div>
            <div id="debugLog" style="max-height:220px;overflow:auto;white-space:pre-wrap;font-size:12px;color:var(--text-muted)"></div>
        </div>

        <div id="modal" class="modal" aria-hidden="true">
            <div class="box" role="dialog" aria-modal="true">
                <div style="display:flex;align-items:center;justify-content:space-between">
                    <strong style="color:var(--accent-primary);font-size:1.25rem">Advanced Settings</strong>
                    <button id="closeModal" class="close-x">✕</button>
                </div>
                <div class="row">
                    <div style="font-weight:700">Debug Mode</div>
                    <label><input type="checkbox" id="debugSwitch" checked> <span style="margin-left:8px;color:var(--text-secondary)">On</span></label>
                </div>
                <div class="row">
                    <div style="font-weight:700">Translation (ml → en)</div>
                    <label><input type="checkbox" id="translationSwitch"> <span style="margin-left:8px;color:var(--text-secondary)">Enable</span></label>
                </div>
                <div id="translationProgressBox" style="display:none;padding-top:8px">
                    <div style="font-weight:700;color:var(--text-secondary)">Translating titles <span id="translationCount" style="font-weight:900">0/0</span></div>
                    <div class="progress-track" style="margin-top:8px">
                        <div id="translationFill" class="progress-fill"></div>
                    </div>
                </div>
                <div style="text-align:right;margin-top:12px">
                    <button id="closeModalBtn" class="btn copy">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* All your JavaScript code is here. It is one large script block for simplicity. */
        class RSSFeedReader {
            constructor(config = {}) {
                // ... (your existing constructor code)
                this.channels = config.channels || [];
                this.initialChannels = [...this.channels];
                this.currentChannelId = config.defaultChannelId || this.channels[0].id;
                this.YT_API_KEY = config.YT_API_KEY || 'AIzaSyA7j_nUEdvaNeFpJx5tBj4-VzlOpKXTkCg';
                this.pollIntervalMs = config.pollIntervalMs || 60000;
                this.forceStatusIntervalMs = config.forceStatusIntervalMs || 5 * 60 * 1000;
                this.knownItemsKeyPrefix = 'rss-known-items-v1-';
                this.feedMap = new Map();
                this.isDebugging = true;
                this.isTranslationEnabled = false;
                this.translationInProgress = false;
                this.allChannelData = new Map();
                this.isTestMode = false;
                this.testModeInterval = null;
                this.titleTapCount = 0;
                this.titleTapTimer = null;
                this.testModePosts = new Map();
                this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;
                this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
                this.lastFetchedEtag = localStorage.getItem('rss-etag-' + this.currentChannelId) || '';
                this.lastFetchedModified = localStorage.getItem('rss-last-modified-' + this.currentChannelId) || '';
                this.mainTitleEl = document.getElementById('mainTitle');
                this.feedListEl = document.getElementById('feedList');
                this.loadingBox = document.getElementById('loadingBox');
                this.debugLogEl = document.getElementById('debugLog');
                this.feedTimerEl = document.getElementById('feedTimer');
                this.ytTimerEl = document.getElementById('ytTimer');
                this.lastCandidateEl = document.getElementById('lastCandidate');
                this.statusTextEl = document.getElementById('statusText');
                this.statusIndicatorEl = document.getElementById('statusIndicator');
                this.lastUpdateEl = document.getElementById('lastUpdate');
                this.totalPostsEl = document.getElementById('totalPosts');
                this.newPostsEl = document.getElementById('newPosts');
                this.translationFillEl = document.getElementById('translationFill');
                this.translationCountEl = document.getElementById('translationCount');
                this.translationProgressBox = document.getElementById('translationProgressBox');
                this.channelSelectEl = document.getElementById('channelSelect');
                this.notificationEl = document.getElementById('newPostNotification');
                this.filterBtns = {
                    'new': document.querySelector('[data-filter="new"]'),
                    'all': document.querySelector('[data-filter="all"]'),
                    'released': document.querySelector('[data-filter="released"]'),
                    'scheduled': document.querySelector('[data-filter="scheduled"]'),
                    'live': document.querySelector('[data-filter="live"]')
                };
                this.audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
                this.fetchInterval = null;
                this.debugInterval = null;
                this.forceStatusTimer = null;
                this.setupUI();
                this.logMessage('App initializing...');
                this.updateChannelSelector(this.channels);
                this.loadChannelFeeds();
                this.fetchFeeds();
                this.fetchInterval = setInterval(() => this.fetchFeeds(), this.pollIntervalMs);
                this.debugInterval = setInterval(() => this.updateDebugTimers(), 1000);
                this.registerServiceWorker();
            }
            // ... (rest of your class methods)
            async requestNotificationPermission() {
                if (!('Notification' in window)) {
                    this.logMessage('This browser does not support desktop notifications.');
                    return;
                }
                if (Notification.permission === 'granted') {
                    this.logMessage('Notification permission already granted.');
                    return;
                }
                if (Notification.permission !== 'denied') {
                    const permission = await Notification.requestPermission();
                    this.logMessage('Notification permission ' + permission);
                } else {
                    this.logMessage('Notification permission denied by user.');
                }
            }

            sendPushNotification(title, body) {
                if ('serviceWorker' in navigator && Notification.permission === 'granted') {
                    navigator.serviceWorker.ready.then(registration => {
                        registration.showNotification(title, {
                            body: body,
                            icon: 'https://cdn.iconscout.com/icon/premium/png-64-thumb/prayer-1361952-1153676.png',
                            vibrate: [200, 100, 200]
                        });
                    });
                } else {
                    this.logMessage('Cannot show notification. SW not ready or permission denied.');
                }
            }

            loadKnownItems(channelId) {
                try {
                    const s = localStorage.getItem(this.knownItemsKeyPrefix + channelId);
                    return s ? new Set(JSON.parse(s)) : new Set();
                } catch (e) {
                    console.error('loadKnownItems', e);
                    return new Set();
                }
            }

            saveKnownItems(channelId, knownItems) {
                localStorage.setItem(this.knownItemsKeyPrefix + channelId, JSON.stringify(Array.from(knownItems)));
            }

            setupUI() {
                document.getElementById('openSettings').addEventListener('click', () => this.openModal());
                document.getElementById('closeModal').addEventListener('click', () => this.closeModal());
                document.getElementById('closeModalBtn').addEventListener('click', () => this.closeModal());
                document.getElementById('refreshBtn').addEventListener('click', () => {
                    this.fetchFeeds();
                    this.showMessage('Manual refresh triggered!');
                });
                document.getElementById('mainTitleContainer').addEventListener('click', () => this.handleTitleTap());

                document.getElementById('debugSwitch').addEventListener('change', (e) => {
                    this.isDebugging = e.target.checked;
                    document.getElementById('debug').style.display = this.isDebugging ? '' : 'none';
                });

                document.getElementById('translationSwitch').addEventListener('change', async (e) => {
                    this.isTranslationEnabled = e.target.checked;
                    this.logMessage('Translation toggled ' + (this.isTranslationEnabled ? 'ON' : 'OFF'));
                    if (this.isTranslationEnabled) await this.translateAllTitles();
                    else this.renderAllItems();
                });

                document.getElementById('themeToggle').addEventListener('click', () => {
                    const root = document.documentElement;
                    if (root.style.getPropertyValue('--accent-primary') === '#00ff88') {
                        root.style.setProperty('--accent-primary', '#8b5cf6');
                        root.style.setProperty('--accent-secondary', '#06b6d4');
                        root.style.setProperty('--accent-tertiary', '#00ff88');
                        document.getElementById('themeToggle').textContent = '☀️';
                    } else {
                        root.style.setProperty('--accent-primary', '#00ff88');
                        root.style.setProperty('--accent-secondary', '#8b5cf6');
                        root.style.setProperty('--accent-tertiary', '#06b6d4');
                        document.getElementById('themeToggle').textContent = '🌙';
                    }
                });

                document.querySelectorAll('.filter-btn').forEach(btn => btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.applyFilter();
                }));

                document.getElementById('debug').style.display = '';
                this.notificationEl.addEventListener('click', () => {
                    const channelId = this.notificationEl.dataset.channelId;
                    if (channelId) {
                        this.switchChannel(channelId);
                        this.hideNotification();
                    }
                });

                document.body.addEventListener('click', () => {
                    this.requestNotificationPermission();
                }, { once: true });
            }

            handleTitleTap() {
                this.titleTapCount++;
                if (this.titleTapTimer) clearTimeout(this.titleTapTimer);
                if (this.titleTapCount >= 5) {
                    this.toggleTestMode();
                    this.titleTapCount = 0;
                } else {
                    this.titleTapTimer = setTimeout(() => {
                        this.titleTapCount = 0;
                    }, 500);
                }
            }

            updateChannelSelector(channels) {
                this.channelSelectEl.innerHTML = '';
                channels.forEach(channel => {
                    const option = document.createElement('option');
                    option.value = channel.id;
                    option.textContent = channel.name;
                    this.channelSelectEl.appendChild(option);
                });
                this.channelSelectEl.value = this.currentChannelId;
                this.channelSelectEl.addEventListener('change', (e) => this.switchChannel(e.target.value));
            }

            openModal() {
                document.getElementById('modal').style.display = 'flex';
            }

            closeModal() {
                document.getElementById('modal').style.display = 'none';
            }

            logMessage(msg) {
                if (!this.isDebugging) return;
                const ts = new Date().toLocaleTimeString('en-GB');
                this.debugLogEl.textContent += `[${ts}] ${msg}\n`;
                this.debugLogEl.scrollTop = this.debugLogEl.scrollHeight;
            }

            updateDebugTimers() {
                const now = Date.now();
                const feedLeft = Math.max(0, this.nextFeedFetchAt - now);
                this.feedTimerEl.textContent = this.isTestMode ? "Test Mode" : this.msToMMSS(feedLeft);
                const ytLeft = Math.max(0, this.nextYTApiAt - now);
                this.ytTimerEl.textContent = this.isTestMode ? "Disabled" : this.msToMMSS(ytLeft);
            }

            msToMMSS(ms) {
                const s = Math.floor(ms / 1000);
                const m = Math.floor(s / 60);
                const sec = s % 60;
                return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
            }

            async tryFetchWithFallbacks(feedUrl, channelId) {
                let lastError = null;
                const headers = {};
                const etagKey = 'rss-etag-' + channelId;
                const lastModKey = 'rss-last-modified-' + channelId;
                const lastFetchedEtag = localStorage.getItem(etagKey) || '';
                const lastFetchedModified = localStorage.getItem(lastModKey) || '';

                if (lastFetchedEtag) headers['If-None-Match'] = lastFetchedEtag;
                if (lastFetchedModified) headers['If-Modified-Since'] = lastFetchedModified;

                const feedCandidates = [
                    feedUrl,
                    'https://cors.kawiesh.top/' + feedUrl,
                    'https://corsproxy.io/?' + encodeURIComponent(feedUrl),
                    'https://api.allorigins.win/raw?url=' + encodeURIComponent(feedUrl)
                ];

                for (const candidate of feedCandidates) {
                    try {
                        this.logMessage(`Attempting fetch for ${channelId}: ${candidate}`);
                        this.lastCandidateEl.textContent = candidate;
                        const r = await fetch(candidate, {
                            cache: 'no-store',
                            headers: headers
                        });

                        if (r.status === 304) {
                            this.logMessage('Server responded with 304 Not Modified. Using cached version.');
                            return { text: null, candidate: 'Cached', isCached: true };
                        }

                        if (!r.ok) {
                            throw new Error('HTTP ' + r.status);
                        }

                        const text = await r.text();
                        if (!text || text.indexOf('<feed') === -1) {
                            this.logMessage('Response did not contain feed XML; skipping candidate.');
                            lastError = new Error('No feed XML in response');
                            continue;
                        }

                        const etag = r.headers.get('ETag');
                        const lastModified = r.headers.get('Last-Modified');
                        if (etag) localStorage.setItem(etagKey, etag);
                        if (lastModified) localStorage.setItem(lastModKey, lastModified);

                        return { text, candidate, isCached: false };
                    } catch (err) {
                        lastError = err;
                        this.logMessage(`Candidate for ${channelId} failed: ${err.message}`);
                    }
                }
                throw lastError || new Error('All fetch attempts failed');
            }

            async fetchFeeds() {
                this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;
                this.logMessage('Starting multi-channel feed fetch...');

                if (this.currentChannelId) {
                    this.setStatus('Fetching...', 'loading');
                }

                const channelsToFetch = this.isTestMode ? this.channels : this.initialChannels;

                for (const channel of channelsToFetch) {
                    try {
                        const { text: xmlText, isCached } = await this.tryFetchWithFallbacks(channel.feedUrl, channel.id);
                        let items = [];
                        let idsInFeed = [];
                        const knownItems = this.loadKnownItems(channel.id);
                        let itemsToProcess = [];

                        if (isCached) {
                            this.logMessage(`Channel ${channel.name} is up to date.`);
                            if (this.allChannelData.has(channel.id)) {
                                itemsToProcess = Array.from(this.allChannelData.get(channel.id).values());
                            }
                        } else {
                            const parser = new DOMParser();
                            const xml = parser.parseFromString(xmlText, 'text/xml');
                            const parsedData = this.parseFeedXml(xml, knownItems);
                            items = parsedData.items;
                            idsInFeed = parsedData.idsInFeed;
                            itemsToProcess = items;
                        }

                        const existingItemsForChannel = this.allChannelData.get(channel.id) || new Map();
                        const newIds = idsInFeed.filter(id => !knownItems.has(id));

                        if (newIds.length > 0) {
                            this.logMessage(`${newIds.length} new items found for channel ${channel.name}.`);
                            this.playDing();
                            this.sendPushNotification(`New Post on ${channel.name}`, `A new post titled "${items.find(i => i.id === newIds[0]).title}" is now available.`);
                            const newVideoIds = items.filter(it => newIds.includes(it.id)).map(i => i.videoId).filter(Boolean);
                            if (newVideoIds.length > 0 && !this.isTestMode) {
                                await this.getLiveStatusForVideoIds(newVideoIds, items);
                            }
                            this.updateKnownItems(items, knownItems, newIds, channel.id);
                            if (channel.id !== this.currentChannelId) {
                                this.showNotification(`New post from ${channel.name}!`, channel.id);
                            }
                        }

                        const newMap = new Map();
                        for(const item of itemsToProcess) {
                            let existingItem = existingItemsForChannel.get(item.id);
                            if(existingItem) {
                                if (item.liveStreamingDetails) {
                                    existingItem.liveStreamingDetails = item.liveStreamingDetails;
                                }
                                newMap.set(item.id, existingItem);
                            } else {
                                newMap.set(item.id, item);
                            }
                        }
                        this.allChannelData.set(channel.id, newMap);

                        const allCurrentItems = Array.from(this.allChannelData.get(channel.id).values());
                        const videosWithoutLiveStatus = allCurrentItems
                            .filter(item => item.liveStreamingDetails === null)
                            .map(item => item.videoId)
                            .filter(Boolean);
                        if (videosWithoutLiveStatus.length > 0 && !this.isTestMode) {
                            await this.getLiveStatusForVideoIds(videosWithoutLiveStatus, allCurrentItems);
                        }

                        if (channel.id === this.currentChannelId) {
                            this.updateCurrentFeedFromAllChannelData();
                        }

                    } catch (err) {
                        console.error(`fetchFeed for ${channel.name} error`, err);
                        this.logMessage(`Feed fetch error for ${channel.name}: ` + (err && err.message ? err.message : 'Unknown error'));
                        if (channel.id === this.currentChannelId) {
                            this.setStatus('Error', 'error');
                            this.showError(`Failed to load RSS feed for ${channel.name}: ` + (err && err.message ? err.message : 'Unknown error'));
                        }
                    }
                }
                if (this.currentChannelId) {
                    this.setStatus('Connected', 'connected');
                    this.updateLastUpdateTime();
                }
            }

            updateCurrentFeedFromAllChannelData() {
                if (this.isTestMode) {
                    this.feedMap = this.testModePosts;
                } else {
                    this.feedMap = this.allChannelData.get(this.currentChannelId) || new Map();
                }
                this.renderAllItems();
                this.updateTotals();
                this.applyFilter();
                if (this.feedMap.size === 0 && !this.isTestMode) {
                    this.logMessage('Feed empty — scheduling forced YT status checks every 5 minutes.');
                    this.scheduleForceStatusChecks();
                } else {
                    this.clearForceStatusChecks();
                }
                if (this.isTranslationEnabled) {
                    this.translateAllTitles();
                }
            }

            updateKnownItems(items, knownItems, newIds, channelId) {
                newIds.forEach(id => {
                    knownItems.add(id);
                });
                this.saveKnownItems(channelId, knownItems);
            }

            parseFeedXml(xmlDoc, knownItems) {
                const entries = Array.from(xmlDoc.querySelectorAll('entry'));
                const items = [];
                const idsInFeed = [];
                for (const entry of entries) {
                    const id = entry.querySelector('id')?.textContent || '';
                    if (!id) continue;
                    if (idsInFeed.includes(id)) continue;
                    idsInFeed.push(id);

                    const originalTitle = entry.querySelector('title')?.textContent || 'No title';
                    const link = entry.querySelector('link')?.getAttribute('href') || '#';
                    const published = entry.querySelector('published')?.textContent || '';
                    const updated = entry.querySelector('updated')?.textContent || '';

                    const mediaGroup = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'group')[0];
                    let summary = entry.querySelector('summary')?.textContent || 'No description available';
                    if (mediaGroup) {
                        const desc = mediaGroup.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'description')[0];
                        if (desc && desc.textContent.trim() !== '') summary = desc.textContent;
                    }

                    const community = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'community')[0];
                    const starRating = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'starRating')[0]?.getAttribute('average') || '0.00';
                    const ratingCount = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'starRating')[0]?.getAttribute('count') || '0';
                    const views = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'statistics')[0]?.getAttribute('views') || '0';

                    const videoId = this.extractVideoId(link);
                    const thumbnail = videoId ? `https://cors.kawiesh.top/https://i2.ytimg.com/vi/${videoId}/hqdefault.jpg` : null;
                    const isNew = !knownItems.has(id);
                    const hasStats = parseInt(views) > 0;

                    items.push({
                        id,
                        title: originalTitle,
                        originalTitle,
                        translatedTitle: null,
                        link,
                        published: this.parseDateTime(published),
                        updated: this.parseDateTime(updated),
                        summary: this.cleanSummary(summary),
                        thumbnail,
                        community: { starRating, ratingCount, views },
                        videoId,
                        isNew,
                        hasStats,
                        liveStreamingDetails: null
                    });
                }
                items.sort((a, b) => new Date(b.published.full) - new Date(a.published.full));
                return { items, idsInFeed };
            }

            async getLiveStatusForVideoIds(videoIdList = [], items) {
                if (this.isTestMode || !this.YT_API_KEY || this.YT_API_KEY === 'AIzaSyA7j_nUEdvaNeFpJx5tBj4-VzlOpKXTkCg') {
                    this.logMessage('YouTube API key not configured or Test Mode active — skipping live status checks.');
                    return;
                }
                if (!videoIdList || videoIdList.length === 0) {
                    this.logMessage('No video IDs provided for YT API call.');
                    return;
                }

                const chunks = [];
                for (let i = 0; i < videoIdList.length; i += 50) chunks.push(videoIdList.slice(i, i + 50));

                try {
                    for (const chunk of chunks) {
                        const parts = 'id,liveStreamingDetails';
                        const url = `https://www.googleapis.com/youtube/v3/videos?part=${parts}&id=${chunk.join(',')}&key=${this.YT_API_KEY}`;
                        this.logMessage(`Calling YouTube API for ${chunk.length} videos...`);
                        const res = await fetch(url);
                        if (!res.ok) {
                            this.logMessage(`YouTube API returned ${res.status}`);
                            continue;
                        }
                        const data = await res.json();
                        if (!data.items) continue;
                        for (const obj of data.items) {
                            const vid = obj.id;
                            const liveDetails = obj.liveStreamingDetails || null;
                            for (const item of items) {
                                if (item.videoId === vid) {
                                    item.liveStreamingDetails = liveDetails;
                                }
                            }
                        }
                    }
                    this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
                } catch (err) {
                    console.error('YT API error', err);
                    this.logMessage('YT API error: ' + (err && err.message ? err.message : err));
                }
            }

            scheduleForceStatusChecks() {
                if (this.forceStatusTimer) return;
                this.forceStatusTimer = setInterval(async () => {
                    this.logMessage('Forced YT status check (feed empty).');
                    const knownVideoIds = Array.from(this.feedMap.values()).map(i => i.videoId).filter(Boolean);
                    if (knownVideoIds.length > 0) await this.getLiveStatusForVideoIds(knownVideoIds);
                    else this.logMessage('No known video ids to check.');
                }, this.forceStatusIntervalMs);
            }

            clearForceStatusChecks() {
                if (this.forceStatusTimer) {
                    clearInterval(this.forceStatusTimer);
                    this.forceStatusTimer = null;
                    this.logMessage('Cleared forced YT checks.');
                }
            }

            getOrCreateList() {
                if (!this.feedListEl) this.feedListEl = document.getElementById('feedList');
                return this.feedListEl;
            }

            makeItemHtml(item) {
                const displayTitle = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;
                let dateDisplay = '';
                let communityHtml = '';
                let postClass = item.isNew ? ' new' : '';
                let copyDate = item.published?.date || '';
                let copyTime = item.published?.time || '';
                let copyType = 'Date';
                let newBadgeHtml = item.isNew ? `<div class="new-badge">NEW</div>` : '';
                let communityCopyText = '';
                const isLive = item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime;
                const isScheduled = item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime;
                const isReleased = !item.liveStreamingDetails || (!item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.scheduledStartTime) || (item.liveStreamingDetails.actualEndTime);

                if (isLive) {
                    dateDisplay = '🔴 Live Now';
                    communityHtml = `<div class="meta">📈 Community Stats: Live stream in progress!</div>`;
                    postClass += ' no-stats-post';
                } else if (isScheduled) {
                    const sched = this.parseDateTime(item.liveStreamingDetails.scheduledStartTime);
                    dateDisplay = `⏰ Scheduled: ${sched.date} ${sched.time}`;
                    copyDate = sched.date;
                    copyTime = sched.time;
                    copyType = 'Scheduled';
                    postClass += ' no-stats-post';
                } else if (isReleased) {
                    dateDisplay = `📅 Published: ${item.published?.date || 'Unknown'} ${item.published?.time || ''}`;
                    if (item.updated) dateDisplay += ` | 🔄 Updated: ${item.updated.date} ${item.updated.time}`;
                    if (item.hasStats) {
                        const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views || 0);
                        const starRating = '⭐'.repeat(Math.round(parseFloat(item.community.starRating || 0)));
                        communityHtml = `<div class="meta">📈 ${starRating} (${item.community.starRating} avg) • 👀 ${formattedViews}</div>`;
                        communityCopyText = `\n\n📈 ⭐⭐⭐⭐⭐ (${item.community.starRating} avg) • 👀 ${formattedViews}`;
                    } else {
                        communityHtml = `<div class="meta">📈 Community Stats: Not yet available</div>`;
                        postClass += ' no-stats-post';
                    }
                }

                const descriptionHtml = item.hasStats ? `<div class="desc">${this.escapeHtml(item.summary)}</div>` : '';
                const thumbHtml = item.thumbnail ? `<div class="thumb" data-video-id="${this.escapeHtml(item.videoId || '')}" data-item-id="${this.escapeHtml(item.id)}"><img src="${this.escapeHtml(item.thumbnail)}" alt="${this.escapeHtml(displayTitle)}"><div class="play"></div></div>` : '';

                return `
                    <div class="feed-item ${postClass}" data-item-id="${this.escapeHtml(item.id)}" data-video-id="${this.escapeHtml(item.videoId || '')}" data-copy-type="${copyType}" data-copy-date="${copyDate}" data-copy-time="${copyTime}">
                        ${newBadgeHtml}
                        ${thumbHtml}
                        <div class="content">
                            <div class="title-line">${this.escapeHtml(displayTitle)}</div>
                            <div class="meta">${dateDisplay}</div>
                            ${descriptionHtml}
                            ${communityHtml}
                            <div class="actions" style="margin-top:10px">
                                <a class="btn watch" href="${this.escapeHtml(item.link)}" target="_blank" onclick="event.stopPropagation()">🎬 Watch</a>
                                <button class="btn copy" data-item-id="${this.escapeHtml(item.id)}" data-community-copy="${this.jsEscape(communityCopyText)}">📋 Copy Info</button>
                            </div>
                        </div>
                    </div>
                `;
            }

            insertItemToDOM(item, prepend = false) {
                const wrapper = document.createElement('div');
                wrapper.innerHTML = this.makeItemHtml(item);
                const node = wrapper.firstElementChild;
                if (!node) return;
                const list = this.getOrCreateList();
                if (this.loadingBox) {
                    this.loadingBox.remove();
                    this.loadingBox = null;
                }
                if (prepend) list.insertBefore(node, list.firstChild);
                else list.appendChild(node);
                this.attachHandlers(node);
            }

            updateItemInDOM(item) {
                const sel = `.feed-item[data-item-id="${this.escapeCssSelector(item.id)}"]`;
                const existing = document.querySelector(sel);
                if (!existing) {
                    this.insertItemToDOM(item, true);
                    return;
                }
                const wrapper = document.createElement('div');
                wrapper.innerHTML = this.makeItemHtml(item);
                const newNode = wrapper.firstElementChild;
                existing.replaceWith(newNode);
                this.attachHandlers(newNode);
            }

            removeItemFromDOM(id) {
                const node = document.querySelector(`.feed-item[data-item-id="${this.escapeCssSelector(id)}"]`);
                if (node) node.remove();
            }

            attachHandlers(root) {
                const thumb = root.querySelector('.thumb');
                if (thumb) {
                    thumb.addEventListener('click', (ev) => {
                        const vid = thumb.dataset.videoId;
                        const item = this.feedMap.get(thumb.dataset.itemId);
                        if (vid) {
                            const iframeWrapper = this.createIframeWrapper(vid, item);
                            thumb.replaceWith(iframeWrapper);
                            this.logMessage(`Starting playback for ${vid}`);
                            this.updateMediaSession(item);
                        }
                        ev.stopPropagation();
                    });
                }
                const copyBtn = root.querySelector('.btn.copy');
                if (copyBtn) {
                    copyBtn.addEventListener('click', (e) => {
                        const id = copyBtn.getAttribute('data-item-id');
                        this.copyToClipboardById(id);
                    });
                }
            }

            createIframeWrapper(videoId, item) {
                const wrapper = document.createElement('div');
                wrapper.className = 'video-player-wrapper';
                wrapper.dataset.videoId = videoId;
                const iframe = document.createElement('iframe');
                iframe.width = "280";
                iframe.height = "158";
                iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1`;
                iframe.frameBorder = "0";
                iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                iframe.allowFullscreen = true;
                wrapper.appendChild(iframe);

                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-player-btn';
                closeBtn.textContent = '✕';
                closeBtn.onclick = () => {
                    iframe.src = '';
                    const parentItem = closeBtn.closest('.feed-item');
                    if (parentItem) {
                        const originalThumbHtml = this.makeItemHtml(item);
                        const newThumb = this.createNodeFromHtml(originalThumbHtml).querySelector('.thumb');
                        if (newThumb) {
                            wrapper.replaceWith(newThumb);
                            this.attachHandlers(parentItem);
                        }
                    }
                    this.clearMediaSession();
                };
                wrapper.appendChild(closeBtn);
                return wrapper;
            }

            updateMediaSession(item) {
                if ('mediaSession' in navigator) {
                    const title = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;
                    const channelName = this.channels.find(c => c.id === this.currentChannelId)?.name || 'Prayer Feed';
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: title,
                        artist: channelName,
                        album: 'YouTube Live',
                        artwork: [
                            { src: item.thumbnail, sizes: '280x158', type: 'image/jpeg' }
                        ]
                    });
                    navigator.mediaSession.playbackState = 'playing';

                    navigator.mediaSession.setActionHandler('play', () => {
                        const iframe = document.querySelector(`[data-video-id="${item.videoId}"] iframe`);
                        if (iframe) {
                            iframe.contentWindow.postMessage('{"event":"command","func":"playVideo"}', '*');
                            navigator.mediaSession.playbackState = 'playing';
                        }
                    });
                    navigator.mediaSession.setActionHandler('pause', () => {
                        const iframe = document.querySelector(`[data-video-id="${item.videoId}"] iframe`);
                        if (iframe) {
                            iframe.contentWindow.postMessage('{"event":"command","func":"pauseVideo"}', '*');
                            navigator.mediaSession.playbackState = 'paused';
                        }
                    });
                }
            }

            clearMediaSession() {
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = null;
                    navigator.mediaSession.playbackState = 'none';
                    this.logMessage('Media Session cleared.');
                }
            }

            copyToClipboardById(id) {
                const item = this.feedMap.get(id);
                if (!item) return;
                const title = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;
                const communityCopyText = item.hasStats ? `\n\n📈 ⭐⭐⭐⭐⭐ (${item.community.starRating} avg) • 👀 ${new Intl.NumberFormat('en-IN').format(item.community.views)}` : '';

                let text;
                if (item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime) {
                    const dt = this.parseDateTime(item.liveStreamingDetails.actualStartTime);
                    text = `Title: ${title}\n🔴 Live Now\n\nDate: ${dt.date} ${dt.time}\nURL: ${item.link}`;
                } else if (item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime) {
                    const dt = this.parseDateTime(item.liveStreamingDetails.scheduledStartTime);
                    text = `Title: ${title}\n\n⏰ Scheduled: ${dt.date} ${dt.time}\nURL: ${item.link}`;
                } else {
                    let date = item.published?.date || '';
                    let time = item.published?.time || '';
                    text = `Title: ${title}\n\nDate: ${date} ${time}${communityCopyText}\nURL: ${item.link}`;
                }

                this.copyRawText(text);
                this.showMessage('Video info copied to clipboard!');
            }

            copyRawText(s) {
                const ta = document.createElement('textarea');
                ta.value = s;
                document.body.appendChild(ta);
                ta.select();
                try {
                    document.execCommand('copy');
                } catch (e) {
                    this.logMessage('Copy failed: ' + e.message);
                }
                ta.remove();
            }

            showMessage(text) {
                this.logMessage('UI: ' + text);
                const prev = document.getElementById('flashMsg');
                if (prev) prev.remove();
                const el = document.createElement('div');
                el.id = 'flashMsg';
                el.style.position = 'fixed';
                el.style.right = '18px';
                el.style.bottom = '18px';
                el.style.background = 'linear-gradient(90deg,var(--accent-secondary),var(--accent-primary))';
                el.style.color = 'var(--bg-primary)';
                el.style.padding = '10px 14px';
                el.style.borderRadius = '10px';
                el.style.fontWeight = '800';
                el.textContent = text;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 1800);
            }

            extractVideoId(url) {
                if (!url) return null;
                const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
                const m = url.match(regex);
                return m ? m[1] : null;
            }

            parseDateTime(dateString) {
                if (!dateString) return { date: '', time: '', full: null };
                const d = new Date(dateString);
                const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true, timeZone: 'Asia/Kolkata' };
                const fmt = new Intl.DateTimeFormat('en-GB', options);
                const parts = fmt.formatToParts(d);
                const dateFormatted = `${parts.find(p => p.type === 'day').value}-${parts.find(p => p.type === 'month').value}-${parts.find(p => p.type === 'year').value}`;
                const timeFormatted = `${parts.find(p => p.type === 'hour').value}:${parts.find(p => p.type === 'minute').value}:${parts.find(p => p.type === 'second').value} ${parts.find(p => p.type === 'dayPeriod').value}`;
                return { date: dateFormatted, time: timeFormatted, full: d.toString() };
            }

            cleanSummary(s) {
                if (!s) return '';
                const r = s.replace(/<[^>]*>/g, '').trim();
                return r.length > 200 ? r.substring(0, 200) + '...' : r;
            }

            escapeHtml(t) {
                const d = document.createElement('div');
                d.textContent = t;
                return d.innerHTML;
            }

            escapeCssSelector(s) {
                if (window.CSS && CSS.escape) return CSS.escape(s);
                return String(s).replace(/(["\\])/g, '\\$1');
            }

            jsEscape(s) {
                if (!s) return '';
                return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '');
            }

            async translateTitle(text) {
                if (!text || text.trim() === '') return 'No title';
                if (/^[\x00-\x7F]+$/.test(text)) return text;
                try {
                    const resp = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=ml&tl=en&dt=t&q=${encodeURIComponent(text)}`);
                    if (!resp.ok) throw new Error('Translate API ' + resp.status);
                    const data = await resp.json();
                    const translated = data?.[0]?.[0]?.[0] || text;
                    return translated;
                } catch (err) {
                    this.logMessage('Translation failed: ' + (err && err.message ? err.message : err));
                    return text;
                }
            }

            async translateAllTitles() {
                if (this.translationInProgress) return;
                const items = Array.from(this.feedMap.values()).filter(it => !it.translatedTitle);
                if (items.length === 0) {
                    this.logMessage('No titles to translate.');
                    return;
                }
                this.translationInProgress = true;
                this.translationProgressBox.style.display = '';
                const total = items.length;
                this.translationCountEl.textContent = `0/${total}`;
                this.translationFillEl.style.width = '0%';
                let done = 0;
                for (const item of items) {
                    if (!this.isTranslationEnabled) {
                        this.logMessage('Translation cancelled by user');
                        break;
                    }
                    try {
                        const translated = await this.translateTitle(item.originalTitle);
                        item.translatedTitle = translated;
                        this.feedMap.set(item.id, item);
                        this.updateItemInDOM(item);
                    } catch (err) {
                        this.logMessage('Translate error for item: ' + (err && err.message ? err.message : err));
                    }
                    done++;
                    this.translationCountEl.textContent = `${done}/${total}`;
                    this.translationFillEl.style.width = `${Math.round((done / total) * 100)}%`;
                }
                setTimeout(() => {
                    this.translationProgressBox.style.display = 'none';
                }, 600);
                this.translationInProgress = false;
                this.logMessage('Translation pass finished/stopped.');
            }

            playDing() {
                if (this.audioCtx) {
                    try {
                        const ctx = this.audioCtx;
                        const o = ctx.createOscillator();
                        const g = ctx.createGain();
                        o.type = 'sine';
                        o.frequency.setValueAtTime(880, ctx.currentTime);
                        g.gain.setValueAtTime(0, ctx.currentTime);
                        o.connect(g);
                        g.connect(ctx.destination);
                        g.gain.linearRampToValueAtTime(0.22, ctx.currentTime + 0.01);
                        o.frequency.exponentialRampToValueAtTime(1320, ctx.currentTime + 0.12);
                        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.9);
                        o.start(ctx.currentTime);
                        o.stop(ctx.currentTime + 0.95);
                        this.logMessage('Playing: ding (WebAudio)');
                    } catch (e) {
                        this.logMessage('WebAudio play failed: ' + e.message);
                    }
                } else {
                    this.logMessage('No WebAudio available for ding.');
                }
            }

            updateTotals() {
                const total = this.feedMap.size;
                const released = Array.from(this.feedMap.values()).filter(item => !item.liveStreamingDetails || (item.liveStreamingDetails && (item.liveStreamingDetails.actualEndTime || (!item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.scheduledStartTime)))).length;
                const scheduled = Array.from(this.feedMap.values()).filter(item => item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime).length;
                const live = Array.from(this.feedMap.values()).filter(item => item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime).length;
                const newCount = Array.from(this.feedMap.values()).filter(i => i.isNew).length;

                this.filterBtns['all'].textContent = `All (${total})`;
                this.filterBtns['new'].textContent = `New (${newCount})`;
                this.filterBtns['released'].textContent = `Released (${released})`;
                this.filterBtns['scheduled'].textContent = `Scheduled (${scheduled})`;
                this.filterBtns['live'].textContent = `Live (${live})`;

                this.totalPostsEl.textContent = total;
                this.newPostsEl.textContent = newCount;

                this.filterBtns['new'].style.display = newCount > 0 ? 'inline-block' : 'none';
                this.filterBtns['released'].style.display = released > 0 ? 'inline-block' : 'none';
                this.filterBtns['scheduled'].style.display = scheduled > 0 ? 'inline-block' : 'none';
                this.filterBtns['live'].style.display = live > 0 ? 'inline-block' : 'none';
            }

            setStatus(text, className) {
                this.statusTextEl.textContent = text;
                this.statusIndicatorEl.className = 'status-ind';
                if (className === 'loading') this.statusIndicatorEl.classList.add('loading');
                else if (className === 'connected') this.statusIndicatorEl.classList.add('connected');
                else if (className === 'error') this.statusIndicatorEl.classList.add('error');
            }

            updateLastUpdateTime() {
                const now = new Date();
                const opts = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' };
                this.lastUpdateEl.textContent = now.toLocaleString('en-GB', opts);
            }

            showError(msg) {
                const list = this.getOrCreateList();
                if (!this.loadingBox) {
                    const box = document.createElement('div');
                    box.style.padding = '12px';
                    box.style.borderRadius = '10px';
                    box.style.background = 'linear-gradient(90deg, rgba(255,0,0,0.06), rgba(255,0,0,0.02))';
                    box.style.color = '#ffdddd';
                    box.textContent = msg;
                    list.prepend(box);
                } else {
                    this.loadingBox.textContent = msg;
                }
            }

            showNotification(message, channelId) {
                this.notificationEl.textContent = message;
                this.notificationEl.dataset.channelId = channelId;
                this.notificationEl.classList.add('show');
                setTimeout(() => {
                    this.hideNotification();
                }, 5000);
            }

            hideNotification() {
                this.notificationEl.classList.remove('show');
                this.notificationEl.dataset.channelId = '';
            }

            renderAllItems() {
                const list = this.getOrCreateList();
                list.innerHTML = '';
                const sortedItems = Array.from(this.feedMap.values()).sort((a, b) => new Date(b.published.full) - new Date(a.published.full));
                if (sortedItems.length === 0) {
                    if (!this.loadingBox) {
                        const box = document.createElement('div');
                        box.id = 'loadingBox';
                        box.style.padding = '28px';
                        box.style.textAlign = 'center';
                        box.style.color = 'var(--text-muted)';
                        box.innerHTML = `<div style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.04);border-top-color:var(--accent-primary);margin:0 auto 12px;animation:spin 1s linear infinite"></div>Loading RSS feed...`;
                        list.appendChild(box);
                        this.loadingBox = box;
                    } else {
                        this.loadingBox.textContent = this.isTestMode ? 'Generating test posts...' : 'No posts found for this channel.';
                    }
                } else {
                    if (this.loadingBox) { this.loadingBox.remove(); this.loadingBox = null; }
                    for (const item of sortedItems) {
                        const node = this.createNodeFromHtml(this.makeItemHtml(item));
                        this.attachHandlers(node);
                        list.appendChild(node);
                    }
                }
                this.updateTotals();
                this.applyFilter();
            }

            createNodeFromHtml(html) {
                const wrapper = document.createElement('div');
                wrapper.innerHTML = html;
                return wrapper.firstElementChild;
            }

            applyFilter() {
                const active = document.querySelector('.filter-btn.active')?.dataset.filter || 'all';
                for (const node of document.querySelectorAll('.feed-item')) {
                    const id = node.dataset.itemId;
                    const item = this.feedMap.get(id);
                    if (!item) continue;
                    let show = true;
                    if (active === 'new') show = item.isNew;
                    else if (active === 'released') show = !item.liveStreamingDetails || (item.liveStreamingDetails && (item.liveStreamingDetails.actualEndTime || (!item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.scheduledStartTime)));
                    else if (active === 'scheduled') show = item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime;
                    else if (active === 'live') show = item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime;
                    else if (active === 'all') show = true;
                    node.style.display = show ? '' : 'none';
                }
            }

            loadChannelFeeds() {
                this.currentChannelId = this.channelSelectEl.value;
                this.feedMap = this.allChannelData.get(this.currentChannelId) || new Map();

                if (this.isTestMode) {
                    this.feedMap = this.testModePosts;
                }

                this.renderAllItems();
            }

            async switchChannel(channelId) {
                this.currentChannelId = channelId;
                this.channelSelectEl.value = channelId;
                this.loadChannelFeeds();
                this.setStatus('Fetching...', 'loading');
                await this.fetchFeeds();
            }

            toggleTestMode() {
                this.isTestMode = !this.isTestMode;
                this.allChannelData.clear();

                if (this.isTestMode) {
                    this.logMessage('Entering TEST MODE. Real channels are hidden.');
                    this.mainTitleEl.textContent = 'Testing Mode';
                    this.channels = [
                        { id: 'TEST-1', name: 'Test-1', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UC_aEa8K-EOJ3D6gOs7HcyNg' },
                        { id: 'TEST-2', name: 'Test-2', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UC_aEa8K-EOJ3D6gOs7HcyNg' },
                        { id: 'TEST-3', name: 'Test-3', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UC_aEa8K-EOJ3D6gOs7HcyNg' },
                        { id: 'TEST-4', name: 'Test-4', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UC_aEa8K-EOJ3D6gOs7HcyNg' },
                        { id: 'TEST-5', name: 'Test-5', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UC_aEa8K-EOJ3D6gOs7HcyNg' }
                    ];
                    this.currentChannelId = this.channels[0].id;
                    this.updateChannelSelector(this.channels);
                    this.generateTestPosts();
                    this.loadChannelFeeds();
                    this.startTestMode();
                } else {
                    this.logMessage('Exiting TEST MODE. Restoring real channels.');
                    this.mainTitleEl.textContent = 'Prayer Rss Feed';
                    this.stopTestMode();
                    this.channels = [...this.initialChannels];
                    this.currentChannelId = this.initialChannels[0].id;
                    this.updateChannelSelector(this.channels);
                    this.loadChannelFeeds();
                    this.fetchFeeds();
                }
            }

            generateTestPosts() {
                this.testModePosts.clear();
                const now = new Date();
                const generatePost = (id, title, published, isNew, liveDetails = null) => {
                    const vidId = `test_vid_${id}`;
                    return {
                        id: `yt:video:${vidId}`,
                        title: title,
                        originalTitle: title,
                        translatedTitle: null,
                        link: `https://www.youtube.com/watch?v=${vidId}`,
                        published: this.parseDateTime(published.toISOString()),
                        updated: this.parseDateTime(published.toISOString()),
                        summary: `This is a test post for Test Mode with ID ${id}. This post is for demonstration purposes only.`,
                        thumbnail: `https://i.ytimg.com/vi/${vidId}/hqdefault.jpg`,
                        community: { starRating: '4.85', ratingCount: '12345', views: Math.floor(Math.random() * 500000) + 1000 },
                        videoId: vidId,
                        isNew: isNew,
                        hasStats: true,
                        liveStreamingDetails: liveDetails
                    };
                };

                const livePost = generatePost(
                    'live',
                    'Live Prayer Service - Test Stream',
                    now,
                    true,
                    { actualStartTime: now.toISOString(), scheduledStartTime: now.toISOString() }
                );
                this.testModePosts.set(livePost.id, livePost);

                const scheduledTime = new Date(now.getTime() + 60 * 60 * 1000);
                const scheduledPost = generatePost(
                    'scheduled',
                    'Scheduled: Daily Bible Reading - Test',
                    now,
                    true,
                    { scheduledStartTime: scheduledTime.toISOString() }
                );
                this.testModePosts.set(scheduledPost.id, scheduledPost);

                for (let i = 1; i <= 15; i++) {
                    const isNew = i <= 3;
                    const daysAgo = i * 2;
                    const publishedDate = new Date(now.getTime() - daysAgo * 24 * 60 * 60 * 1000);
                    const post = generatePost(
                        `released_${i}`,
                        `Message for the Day - Part ${i}`,
                        publishedDate,
                        isNew
                    );
                    this.testModePosts.set(post.id, post);
                }
            }

            startTestMode() {
                this.clearAllIntervals();
                this.updateCurrentFeedFromAllChannelData();
                this.showMessage('Test Mode active. Generating posts...');
                this.setStatus('Test Mode Active', 'connected');
                this.updateLastUpdateTime();
            }

            stopTestMode() {
                this.clearAllIntervals();
                this.fetchInterval = setInterval(() => this.fetchFeeds(), this.pollIntervalMs);
                this.clearForceStatusChecks();
            }

            clearAllIntervals() {
                if(this.fetchInterval) clearInterval(this.fetchInterval);
                if(this.testModeInterval) clearInterval(this.testModeInterval);
            }

            // FIXED: Correct service worker registration
            async registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register('/service-worker.js', { scope: './' });
                        this.logMessage('Service Worker registered successfully. Scope: ' + registration.scope);
                    } catch (error) {
                        this.logMessage('Service Worker registration failed: ' + error);
                    }
                } else {
                    this.logMessage('Service workers are not supported by this browser.');
                }
            }
        }
        /* ===========================
           Boot the RSSFeedReader with logic glue
           =========================== */
        (function boot() {
            const channels = [
                { id: 'UCbg8V1kty3s1kcCch2VHwEw', name: 'Kreupasanam', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCbg8V1kty3s1kcCch2VHwEw' },
                { id: 'UC8ebJ_anG4byfhC_2hT7eKw', name: 'Gregorian TV', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UC8ebJ_anG4byfhC_2hT7eKw' },
                { id: 'UCZKpTXW-WDBMa66qj27CyuQ', name: 'Shahlom TV Live', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCZKpTXW-WDBMa66qj27CyuQ' },
                { id: 'UCsh010y2VMniw_d0yvcjy0g', name: 'Shahlom Television', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCsh010y2VMniw_d0yvcjy0g' },
                { id: 'UCzxfpzSF7mz8j7bNIXyZWmA', name: 'POWERVISION TV', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCzxfpzSF7mz8j7bNIXyZWmA' },
                { id: 'UCc3XALwTEXjw2e4BLxXCOvw', name: 'VachanamTV', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCc3XALwTEXjw2e4BLxXCOvw' },
                { id: 'UCU_5oIcVdb5pjLlhrWrI_Tg', name: 'Divine Mercy Daily News', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCU_5oIcVdb5pjLlhrWrI_Tg' }
            ];

            const app = new RSSFeedReader({
                channels: channels,
                defaultChannelId: 'UCbg8V1kty3s1kcCch2VHwEw',
                YT_API_KEY: 'AIzaSyA7j_nUEdvaNeFpJx5tBj4-VzlOpKXTkCg', // <--- Replace this with your key
                pollIntervalMs: 60000,
                forceStatusIntervalMs: 5 * 60 * 1000
            });

            window.app = app;

            function tickDebugTimers() {
                const now = Date.now();
                app.feedTimerEl.textContent = app.isTestMode ? "Test Mode" : app.msToMMSS(Math.max(0, app.nextFeedFetchAt - now));
                app.ytTimerEl.textContent = app.isTestMode ? "Disabled" : app.msToMMSS(Math.max(0, app.nextYTApiAt - now));
            }

            setInterval(tickDebugTimers, 1000);

            window.addEventListener('error', (e) => {
                app.logMessage('Global error: ' + (e && e.message ? e.message : e));
            });

            document.addEventListener('DOMContentLoaded', () => {
                document.addEventListener('keydown', (e) => {
                    if (e.shiftKey) {
                        switch (e.key.toLowerCase()) {
                            case 'r':
                                e.preventDefault();
                                if (app.isTestMode) {
                                    app.showMessage('Cannot manually refresh in Test Mode. It refreshes automatically.');
                                } else {
                                    app.fetchFeeds();
                                    app.showMessage('Manual refresh triggered!');
                                }
                                break;
                            case ',':
                                e.preventDefault();
                                app.openModal();
                                break;
                            case 't':
                                e.preventDefault();
                                app.toggleTestMode();
                                break;
                        }
                    }
                    if (e.key === 'Escape' && document.getElementById('modal').style.display === 'flex') {
                        app.closeModal();
                    }
                });

                document.documentElement.style.scrollBehavior = 'smooth';

                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.style.opacity = '1';
                            entry.target.style.transform = 'translateY(0)';
                        }
                    });
                }, { threshold: 0.1 });

                const observeNewItems = () => {
                    document.querySelectorAll('.feed-item:not(.observed)').forEach(item => {
                        item.style.opacity = '0';
                        item.style.transform = 'translateY(20px)';
                        item.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                        item.classList.add('observed');
                        observer.observe(item);
                    });
                };

                setTimeout(observeNewItems, 100);

                const feedList = document.getElementById('feedList');
                if (feedList) {
                    const feedObserver = new MutationObserver(observeNewItems);
                    feedObserver.observe(feedList, { childList: true });
                }
            });

            const style = document.createElement('style');
            style.textContent = `
                .feed-item.observed {
                    opacity: 0;
                    transform: translateY(20px);
                    transition: opacity 0.6s ease, transform 0.6s ease;
                }
                ::-webkit-scrollbar {
                    width: 8px;
                }
                ::-webkit-scrollbar-track {
                    background: var(--card-bg);
                    border-radius: 4px;
                }
                ::-webkit-scrollbar-thumb {
                    background: linear-gradient(var(--accent-primary), var(--accent-secondary));
                    border-radius: 4px;
                }
                ::-webkit-scrollbar-thumb:hover {
                    background: linear-gradient(var(--accent-secondary), var(--accent-tertiary));
                }
                ::selection {
                    background: var(--accent-primary);
                    color: var(--bg-primary);
                }
                button:focus, input:focus {
                    outline: 2px solid var(--accent-primary);
                    outline-offset: 2px;
                }
                .status-item[title]:hover::after {
                    content: attr(title);
                    position: absolute;
                    bottom: 100%;
                    left: 50%;
                    transform: translateX(-50%);
                    background: var(--bg-primary);
                    color: var(--text-primary);
                    padding: 0.5rem;
                    border-radius: 0.5rem;
                    font-size: 0.75rem;
                    white-space: nowrap;
                    z-index: 1000;
                    border: 1px solid var(--border-subtle);
                }
            `;
            document.head.appendChild(style);

            document.getElementById('openSettings').setAttribute('title', 'Shift + , to open');
        })();
    </script>
</body>
</html>
